<!DOCTYPE html>
<html lang="pt-BR">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ecmascript</title>


    <script>

        {
            //O Hasting ocorre apenas dentro de um scopo de bloco 
            //Somente a variável criada como var sofre o hasting = elevação
            //3 escopos: global, função e bloco

            //uma cont = constante, não poderá ser alterada. O que foi feito abaixo foi criar uma nova const com o mesmo nome, o que torna possível estando em escopos diferentes.
            console.log(`########################## (var, let e const) em escopos global, função e bloco  `);

            const plataforma = 'Netflix'; //variavel const global
            let serie = 'Friends'; //variavel let global

            { // Escopo de bloco genérico
                // a const e a let criadas no escopo de bloco não sofre o hasting
                const plataforma = "Amazon";
                let serie = 'The Walking Dead';
                console.log(`dentro do bloco:  ${serie} na plataforma: ${plataforma}`);
            }

            function escopoFuncao() {
                var serie = 'Wandinha';
                {
                    var plataforma = 'Disney'; //A variável sefre hasting para a função e não para a global
                    //Se esse escopo de bloco estivesse somente dentro da global, neste cado o hasting seria para a global.
                }
                console.log(`dentro de função:  ${serie} na plataforma: ${plataforma}`);
            }

            //A forma de apresentação abaixo é uma template string, usada para concatenação de strings, todo conteúdo fica entre CREASA (BACKTIKS)
            console.log(`dentro do bloco:  ${serie} na plataforma: ${plataforma}`);
            escopoFuncao();
        }




        {
            console.log(`########################## Funções - Parâmetros default`);

            //A função pode ser criada entrando com os parametros como default 
            //Na chamada da função, os parametros que não forem passados, receberão o valor default
            function contarUmaHistoria(personagem = 'Fubá', atividade = 'Correr no parque', nome_dono = 'João') {
                console.log(`Era uma vez um cachorro chamado ${personagem}, ele adorava ${atividade}, seu dono era o ${nome_dono} e eles viveram felizes para sempre`);
            }
            //Os parametros obrigatoriamente precisam ser passados em ordem conforme a função
            contarUmaHistoria('Repolho', 'Enterrar ossos', 'Pedro');
            contarUmaHistoria('Repolho', 'Enterrar ossos');
            //contarUmaHistoria('Repolho', , 'Pedro');
        }






        {
            console.log(`########################## Feature Arrow function`);
            //quadrado recebe uma função anonima
            // let quadrado = function (x) {
            //     return x * x;
            // }

            //Aqui removemos a palavra function
            // let quadrado = (x) => {
            //   return x * x
            // } 

            let quadrado = x => x * x; //return implícito
            console.log(quadrado); //retorna a expressão da função 
            console.log(`Quadrado: ${quadrado(3)} `);//executa a função passando o paremtro 

            //Em caso de mais de um parametro usa ()
            let soma = (x, y) => x + y; //return implícito
            console.log(`Soma: ${soma(3, 4)}`);//executa a função passando o paremtro 


            // let parOuImpar = function(numero) {
            //   if(numero % 2 === 0) {
            //     return 'par'
            //   } else {
            //     return 'ímpar'
            //   }
            // }

            // let parOuImpar = numero => {
            //   if(numero % 2 === 0) {
            //     return 'par'
            //   } else {
            //     return 'ímpar'
            //   }
            // }

            //variavel recebe o parametro numero (Arrow =>) função 
            let parOuImpar = numero => numero % 2 === 0 ? 'par' : 'ímpar'; //return implícito
            console.log(parOuImpar(155));

        }








        {
            console.log(`########################## Pilar Abstração Procedural Array`);

            //paradigma procedural ################
            //paradigma procedural, adicionando pessoas de forma verbosa 
            const pessoas = Array();

            pessoas[0] = Array();
            pessoas[0]['nome'] = 'Paulo';
            pessoas[0]['idade'] = 41;
            pessoas[0]['sexo'] = 'Masculino';
            pessoas[0]['maior'] = true;

            pessoas[1] = Array();
            pessoas[1]['nome'] = 'Caio';
            pessoas[1]['idade'] = 6;
            pessoas[1]['sexo'] = 'Masculino';
            pessoas[1]['maior'] = false;

            //paradigma procedural, adicionando pessias de forma de funções 
            function adicionarPessoa(nome, idade, sexo, maior) {
                // A const pessoa abaixo, por não conter indices, o JS reconhesse esse Array como Objeto
                // A função pessoa.length retorna Undefiened

                const pessoa = { nome: nome, idade: idade, sexo: sexo, maior: maior };
                // const pessoa = Array();
                // pessoa['nome'] = nome;
                // pessoa['idade'] = idade;
                // pessoa['sexo'] = sexo;
                // pessoa['maior'] = maior;

                //adiciona o objeto pessoa na mtriz de pessoas
                pessoas.push(pessoa);
            }

            function isMaiorDeIdade(pessoa) {
                if (pessoa['maior']) {
                    console.log(`${pessoa['nome']} é maior de idade`)
                } else {
                    console.log(`${pessoa['nome']} é menor de idade`)
                }
            }
            adicionarPessoa('Monique', 40, 'Feminino', true);
            adicionarPessoa('Nina', 5, 'Feminino', true);

            isMaiorDeIdade(pessoas[1]);
            console.log(pessoas);

            // possíveis formas de criar um Array
            const pessoas2 = Array('p1', 'p2', 'p3');
            console.log(pessoas2);
            const pessoas3 = ['p1', 'p2', 'p3'];
            console.log(pessoas3);
            const pessoas4 = { p1: 'pessoa1', p2: 'pessoa2', p3: 'pessoa3' };
            console.log(pessoas4);

            //Cria uma String com os valores da matriz separados por ','
            let teste1 = pessoas2.toString();
            console.log(teste1);

            //Cria uma String com os valores da matriz separados por '*'
            teste1 = pessoas2.join('*');
            console.log(teste1);

            teste1 = pessoas2.splice(1, 2, 't1', 't2');
            console.log(teste1);
            console.log(pessoas2);




            //o typeof usado em uma matriz sempre vai retornar "object" 
            //utilizando a função Array.iaArray() retornsrá true caso o valor for uma matriz
            console.log(typeof pessoas);
            console.log(Array.isArray(pessoas));

        }





    </script>
</head>

<body>
    <div id="output"></div>
</body>

</html>